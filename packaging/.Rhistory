library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
#print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",nb," / ", totalNb))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
return(directedConnectedNodesDT[-1,])
}
# start
if (fusioned) g<-AFMImageNetworksAnalysis@skeletonGraph
else g<-AFMImageNetworksAnalysis@originalGraph
verticesAnalysisDT<-data.table(vid=V(g)$name, node_degree=unname(degree(g)))
nodesAnalysisDT<-copy(verticesAnalysisDT[node_degree>2])
values <- seq(1, nrow(nodesAnalysisDT))
#values <- seq(1, 28)
## Number of workers (R processes) to use:
# Calculate the number of cores
numWorkers <- detectCores() - 1
## Set up the ’cluster’
cl <- makeCluster(numWorkers, type = "PSOCK")
start.time <- Sys.time()
print(start.time)
## Parallel calculation (parLapply):
res <- parLapply(cl, values, workerFunc,
AFMImageNetworksAnalysis@binaryAFMImage,
g,
nodesAnalysisDT)
end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)
## Shut down cluster
stopCluster(cl)
cl <- makeCluster(numWorkers, type = "PSOCK")
start.time <- Sys.time()
print(start.time)
## Parallel calculation (parLapply):
res <- parLapply(cl, values, workerFunc,
AFMImageNetworksAnalysis@binaryAFMImage,
g,
nodesAnalysisDT)
end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)
## Shut down cluster
stopCluster(cl)
AFMImageNetworksAnalysis@binaryAFMImage@fullfilename
AFMImageNetworksAnalysis
AFMImageNetworksAnalysis<-createGraph(AFMImageNetworksAnalysis)
g<-AFMImageNetworksAnalysis@skeletonGraph
V(g)
library(AFM)
library(igraph)
library(data.table)
library(sp)
library(ggplot2)
save(AFMImageNetworksAnalysis, file = "20140521.001_flatten-AFMImageNetworksAnalysis-1.RData")
g<-AFMImageNetworksAnalysis@skeletonGraph
V(g)
AFMImageNetworksAnalysis<-calculateShortestPaths(AFMImageNetworksAnalysis)
library(parallel)
workerFunc <- function(vid1index, binaryAFMImage, g, nodesAnalysisDT) {
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
#print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",nb," / ", totalNb))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
return(directedConnectedNodesDT[-1,])
}
# start
if (fusioned) g<-AFMImageNetworksAnalysis@skeletonGraph
else g<-AFMImageNetworksAnalysis@originalGraph
verticesAnalysisDT<-data.table(vid=V(g)$name, node_degree=unname(degree(g)))
nodesAnalysisDT<-copy(verticesAnalysisDT[node_degree>2])
values <- seq(1, nrow(nodesAnalysisDT))
fusioned<-TRUE
if (fusioned) g<-AFMImageNetworksAnalysis@skeletonGraph
else g<-AFMImageNetworksAnalysis@originalGraph
verticesAnalysisDT<-data.table(vid=V(g)$name, node_degree=unname(degree(g)))
nodesAnalysisDT<-copy(verticesAnalysisDT[node_degree>2])
values <- seq(1, nrow(nodesAnalysisDT))
numWorkers <- detectCores() - 1
## Set up the ’cluster’
cl <- makeCluster(numWorkers, type = "PSOCK")
start.time <- Sys.time()
print(start.time)
## Parallel calculation (parLapply):
res <- parLapply(cl, values, workerFunc,
AFMImageNetworksAnalysis@binaryAFMImage,
g,
nodesAnalysisDT)
end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)
g
V(g)
diameter(g)
dg <- decompose.graph(g)
dg
values
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
#print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",nb," / ", totalNb))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",nb," / ", totalNb))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",nb))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",vid2index))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
allPath
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",vid2index))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
print(allPath)
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",vid2index))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
print(allPath)
print(is.null(allPath$res))
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",vid2index))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
print(allPath)
print(is.null(allPath$res))
print(length(allPath$res))
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
vid1index<-1
library(igraph)
library(AFM)
library(data.table)
directedConnectedNodesDT<-data.table(vid1="", vid2="", shortest_path="",physicalDistance=0)
nb<-0
print(paste0(vid1index," / ", nrow(nodesAnalysisDT)))
#TODO calculate distance matrix
# vid2index by distance
# when nbOfShortestPath for vid1 reach degree of node then break
nbOfShortestPath<-0
vid1Degree<-nodesAnalysisDT[vid1index,]$node_degree
for (vid2index in seq(1, nrow(nodesAnalysisDT))) {
print(paste0(vid1index," / ", nrow(nodesAnalysisDT),"-",vid2index))
vid1<- nodesAnalysisDT[vid1index,]$vid
vid2<- nodesAnalysisDT[vid2index,]$vid
if (!vid1 %in% vid2) {
allPath<-all_shortest_paths(g, vid1, vid2)
print(allPath)
print(is.null(allPath$res))
if (length(allPath$res)>0) {
for(pathIndex in seq(1,length(allPath$res))) {
#if (length(allPath$res)>0) {
path<-allPath$res[[pathIndex]]$name
#TODO is it working if two points are in separate graph ?
numberOfNodesInShortestPath<-length(which(path %in% nodesAnalysisDT$vid == TRUE))
#print(allPath$res[[1]]$name %in% nodesAnalysisDT$vid)
if (numberOfNodesInShortestPath==2) {
#keep
print(c("interresting", vid1, vid2))
nbOfShortestPath<-nbOfShortestPath+1
print(path)
physicalDistance<-calculatePhysicalDistanceFromPath(binaryAFMImage, path)
print(physicalDistance)
#totalPhysicalDistance<-totalPhysicalDistance+physicalDistance
# TODO fill with reverse path
directedConnectedNodesDT<-rbindlist(list(directedConnectedNodesDT,
data.table(vid1=vid1, vid2=vid2, shortest_path=paste0(path, collapse = "-"),physicalDistance=physicalDistance)))
if (nbOfShortestPath==vid1Degree) break;
}
#}
}
}
}
}
library(AFM)
AFMImageNetworksAnalysis<-calculateShortestPaths(AFMImageNetworksAnalysis)
